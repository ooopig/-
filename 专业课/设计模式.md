参考链接：http://c.biancheng.net/view/1317.html
### 1. 设计模式的分类
- （1） 根据目的来分
根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。
创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。
行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。
- （2） 根据作用范围来分
根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。
类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。
对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。
### 2.创建型模式

#### 单例模式
- 单例模式保证全局的单例类只有一个实例，这样可以直接获取并使用。比如数据库的一个连接
- 5种实现方法
    - 饿汉模式：先实例化单例，获取的时候通过静态方法直接获取。缺点是类加载后就完成了实例化，浪费空间
    - 饱汉模式：先把单例设置为null，然后通过静态方法获取单例是再进行实例化，但是可能有多线程同时进行实例化，出现并发问题
    - 逐步改进：一开始可以用synchronized关键字进行同步，但是开销太大，而后改成使用volatile修饰单例，然后通过一次检查判断单例是否已初始化，如果未初始化就使用synchronized代码块，再次检查单例防止在这期间被初始化，而后才真正进行初始化。
    - 静态内部类：静态内部类只在被使用的时候才进行初始化，所以在内部类中进行单例的实例化，只有用到的时候才会运行实例化代码。然后外部类再通过静态方法返回静态内部类的单例即可。
    - 枚举类：枚举类的底层实现其实也是内部类。枚举类确保每个类对象在全局是唯一的。所以保证它是单例，这个方法是最简单的。

#### 工厂模式
- 简单工厂一般是用一个工厂创建多个类的实例。

- 工厂模式一般是指一个工厂服务一个接口，为这个接口的实现类进行实例化

- 抽象工厂模式是指一个工厂服务于一个产品族，一个产品族可能包含多个接口，接口又会包含多个实现类，通过一个工厂就可以把这些绑定在一起，非常方便。

#### 原型模式
- 通过一个实例进行克隆从而获得更多同一原型的实例。使用实例的clone方法即可完成

#### 建造者模式
- 建造者模式中有一个概念叫做链式调用，链式调用为一个类的实例化提供便利，一般提供系列的方法进行实例化，实际上就是将set方法改造一下，将原本返回为空的set方法改为返回this实例，从而实现链式调用。

- 建造者模式在此基础上加入了builder方法，提供给外部进行调用，同样使用链式调用来完成参数注入。

### 结构型模型

#### 适配器模式
- 适配器模式用于将两个不同的类进行适配。

- 适配器模式和代理模式的异同
    比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。

- 适配器模式可以分为类适配器，对象适配器等。
    类适配器通过继承父类就可以把自己适配成父类了。
    而对象适配器则需要把对象传入另一个对象的构造方法中以便进行包装。

#### 代理模式
- 我们发现没有，代理模式说白了就是做 “方法包装” 或做 “方法增强”。

- 其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，

- 然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。

#### 装饰者模式
- 装饰者模式把每个增强类都继承最高级父类。然后需要功能增强时把类实例传入增强类即可，然后增强类在使用时就可以增强原有类的功能了。

- 和代理模式不同的是，装饰者模式每个装饰类都继承父类，并且可以进行多级封装。

### 行为型模式

#### 观察者模式
- 观察者模式对应着一对多的关系模型，一般用于订阅者和消息发布者之间的数据订阅。

- 一般分为观察者和主题，观察者订阅主题，把实例注册到主题维护的观察者列表上。

- 而主题更新数据时自动把数据推给观察者或者通知观察者数据已经更新。

- 但是由于这样的方式消息推送耦合关系比较紧。并且很难在不打开数据的情况下知道数据类型是什么。

- 知道后来为了使数据格式更加灵活，使用了事件和事件监听器的模式，事件包装的事件类型和事件数据，从主题和观察者中解耦。

- 主题当事件发生时，触发该事件的所有监听器，把该事件通过监听器列表发给每个监听器，监听得到事件以后，首先根据自己支持处理的事件类型中找到对应的事件处理器，再用处理器处理对应事件。