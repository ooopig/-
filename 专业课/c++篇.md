**1.c++中堆和栈的区别**
1.管理方式。栈是由编译器自动管理，无需手工控制；堆的申请和释放由开发人员进行，容易产生内存泄漏
2.空间大小。堆的空间按理来说可以和内存的大小一致（4G）；栈的空间大小为2M
3.生长方式。堆是向上生长；栈是向下生长
4.分配效率。栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是c/c++库函数提供的，机制很复杂。库函数会按照一定的算法进行分配。显然，堆的效率比栈要低得多。
5.数据结构：栈先进后出；堆可以惭怍一棵树

**2.运行时内存空间的划分**
按照内存地址由低到高：代码区、数据区（静态数据）、堆、栈

**3.指针和引用的区别**
（1）指针有自己的一块空间，而引用只是一个别名；
（2）使用 sizeof 看一个指针的大小为4字节（32位，如果要是64位的话指针为8字节），而引用则是被引用对象的大小。
（3）指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用。
（4）作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象。
（5）指针在使用中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变。
（6）指针可以是多级，而引用没有分级
（7）如果返回动态分配内存的对象或者内存，必须使用指针，引用可能引起内存泄漏。

**4.new 和 delete 是如何实现的，与 malloc 和 free有什么异同？**
- new操作针对数据类型的处理，分为两种情况：
    （1） 简单数据类型（包括基本数据类型和不需要构造函数的类型）
    简单类型直接调用 operator new 分配内存；
    可以通过new_handler 来处理 new 失败的情况；
    new 分配失败的时候不像 malloc 那样返回 NULL，它直接抛出异常（bad_alloc）。要判断是否分配成功应该用异常捕获的机制；
    （2）复杂数据类型（需要由构造函数初始化对象）
    new 复杂数据类型的时候先调用operator new，然后在分配的内存上调用构造函数。 
- delete也分为两种情况：
    （1） 简单数据类型（包括基本数据类型和不需要析构函数的类型）
    delete简单数据类型默认只是调用free函数。
    （2）复杂数据类型（需要由析构函数销毁对象）
    delete复杂数据类型先调用析构函数再调用operator delete。

- 与 malloc 和 free 的区别：
    （1）属性上：new / delete 是c++关键字，需要编译器支持。 malloc/free是库函数，需要c的头文件支持。
    （2）参数：使用new操作符申请内存分配时无须制定内存块的大小，编译器会根据类型信息自行计算。而mallco则需要显式地指出所需内存的尺寸。
    （3）返回类型：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，故new是符合类型安全性的操作符。而malloc内存成功分配返回的是void *，需要通过类型转换将其转换为我们需要的类型。
    （4）分配失败时：new内存分配失败时抛出bad_alloc异常；malloc分配内存失败时返回 NULL。
    （5）自定义类型：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
    （6）重载：C++允许重载 new/delete 操作符。而malloc为库函数不允许重载。
    （7）内存区域：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。其中自由存储区为：C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

**5.c++中struct和class的区别？**
（1）struct的默认属性是public；class默认是private
（2）在继承关系中，struct默认是public默认是private
（3）class这个关键字还可用于定义模板参数，就等同于typename；而strcut不用与定义模板参数

**6.define和const的区别？**
（1）起作用的阶段： #define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用。
（2）作用的方式：const常量有数据类型，而宏常量没有数据类型，只是简单的字符串替换。编译器可以对前者进行类型安全检查。而对后者没有类型安全检查，并且在字符替换时可能会产生意料不到的错误。
（3）存储的方式：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份，const比较节省空间，避免不必要的内存分配，提高效率。

**7.在c++中 const 和 static 的用法？**
（1）static：
- 修饰全局变量：存储在静态存储区；未经初始化的全局静态变量自动初始化为 0；作用域为整个文件之内。
- 修饰局部变量：存储在静态存储；未经初始化的局部静态变量会被初始化为0；作用域为局部作用域，但离开作用域不被销毁。
- 修饰静态函数：静态函数只能在声明的文件中可见，不能被其他文件引用
- 修饰类的静态成员：在类中，静态成员可以实现多个对象之间的数据共享，静态成员是类的所有对象中共享的成员，而不属于某一个对象；类中的静态成员必须进行显示的初始化
- 修饰类的静态函数：静态函数同类的静态成员变量一个用法，都是属于一个类的方法。而且静态函数中只可以使用类的静态变量。
（2）const：
- 修成类成员：在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数； const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。
- 修饰类函数：该函数中所有变量均不可改变。

**8.构造函数为什么不能是虚函数？**
虚函数相应一个指向vtable虚函数表的指针，但是这个指向vtable的指针事实上是存储在对象的内存空间的。假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。

**9.sizeof 和 strlen 的区别**
（1）sizeof 是一个操作符，strlen 是库函数。
（2）sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。
（3）编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。
（4）数组做 sizeof 的参数不退化，传递给 strlen 就退化为指针了。

**10.c++的多态机制**
（1）静态多态--重载/函数模板
- 与函数的参数类型和顺序有关，而与参数名和返回值无关
- 在编译期间根据参数类型和顺序推断出需要调用哪个函数
（2）动态多态--虚函数
- 在执行时，根据引用对象的实际类型调用相应的方法
- 虚函数表原理
    1.每个包含虚函数的类都会有一个虚函数表
    2.虚函数表属于类，而不属于类的对象
    3.每个对象内部都有一个指针指向类的虚函数表
    4.动态绑定时，先由对象中的指针找到虚函数表，再从虚函数表中找到对应虚函数的指针

**11.哪些函数不能定义为虚函数？**
- （1）友元函数，不是类成员
- （2）构造函数、拷贝构造函数
- （3）全局函数
- （4）静态成员函数，没有this指针
**12.深拷贝和浅拷贝的区别**
- （1）浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，
- （2）深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，
- （3）使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。

**13.指针常量与常量指针的区别**
- （1）指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针是指定义了一个指针，这个（2）指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。
- （3）指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。

**14.内存泄漏和内存溢出的区别**
- （1）内存泄漏：已经动态分配的堆内存由于某种原因没有释放或者无法释放，造成内存空间浪费
- （2）内存溢出：已有内存空间不能满足需要的内存空间，导致数据覆盖在其他有效数据上，造成程序崩溃或系统瘫痪
**15.c++和java的区别**
- （1）c++是编译型语言，Java是半编译半解释型语言，所以运行速度比c++慢
- （2）c++支持struct类型，Java不支持
- （3）c++有指针类型，而Java是引用
- （4）c++的动态内存需要手动释放；Java有自己的内存回收机制
- （5）Java是纯面向对象的语言，所有代码（包括函数、变量）都必须在类中定义。而C++中还有面向过程的东西，比如是全局变量和全局函数。
- （6）c++中支持多继承，java的类继承只能有1个，但是可以集成多个接口
- （7）C++运算符可以重载，但是Java中不可以。同时C++中支持强制自动转型，Java中不行

### 16.c++ STL容器比较
#### vector
- （1）底层实现：动态数组，在堆上开辟连续的空间
- （2）空间扩展：当vector的当前空间不能满足需求的时候，以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对 vector 的任何操作，一旦引起空间重新配置，同时指向原vector 的所有迭代器就都失效了。
- （3）效率：vector 常用来保存需要经常进行随机访问的内容，并且不需要经常对中间元素进行添加删除操作。
- （4）vector中erase方法与algorithn中的remove方法区别：
vector中erase方法真正删除了元素，迭代器不能访问了
remove只是简单地将元素移到了容器的最后面，迭代器还是可以访问到。因为algorithm通过迭代器进行操作，不知道容器的内部结构，所以无法进行真正的删除。
#### list
- （1）底层实现：环形双向链表，在堆上分配空间，空间是离散的
- （2）效率：不支持随机访问，插入和删除元素效率高
#### deque
- （1）底层实现：动态的连续的线性空间，存储在堆中
- （2）支持随机访问内部元素，但是首尾元素查找和删除为O(1)
- （3）与vector的区别：
    - 1.deque 允许于常数时间内对起头端进行元素的插入或移除操作
    - 2.deque没有所谓容量观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接在一起。换句话说，像 vector 那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在 deque 是不会发生的，所以性能比vector高
- （4）deque采用一块map（不是STL的map容器）作为主控，其为一小块连续空间，其中每个元素都是指针，指向另一段较大的连续空间（缓冲区）
#### stack
- （1）底层实现：stack以的queue作为缺省的实现方式
#### set和multiset
- （1）底层实现：红黑树
- （2）重复性：set不允许插入的值重复，multiset允许值重复
- （3）有序性：元素插入后会自动排序
#### map和multimap
- （1）底层实现：红黑树
- （2）重复性：map不允许插入的键值重复，multiset允许键值重复
- （3）有序性：元素插入后会自动排序
#### hashset 和 hashmap
- （1）底层实现：均为hash表
- （2）元素不会自动排序
#### vector、list、map、deque用erase（it）后，迭代器的变化。
- （1）vector和deque是序列式容器，其内存分别是连续空间和分段连续空间，删除迭代器it后，其后面的迭代器都失效了，此时it及其后面的迭代器会自动加1，使it指向被删除元素的下一个元素。
- （2）list删除迭代器it时，其后面的迭代器都不会失效，将前面和后面连接起来即可。
- （3）map也是只能使当前删除的迭代器失效，其后面的迭代器依然有效。
#### map是怎么实现的？查找的复杂度是多少？能不能边遍历边插入？
- 红黑树和散列
- O(logn)
- 不可以，map不像vector，它在对容器执行erase操作后不会返回后一个元素的迭代器，所以不能遍历地往后删除。

### 17.如何理解迭代器iterator
- Iterator(迭代器)用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示，相当于智能指针。包括Input Iterator, Output Iterator, Forward Iterator, Bidirectional Iterator, Random Access Iterator.